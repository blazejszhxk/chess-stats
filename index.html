<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SzachoweRatingi2025</title>
    <link rel="icon" type="image/png" href="https://i.imgur.com/LNkssep.png">

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-CHG6P8VTBN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-CHG6P8VTBN');
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap');
        html, body {
            font-family: 'Poppins', sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .table-container {
            width: 70%;
            max-width: 95%;
            position: relative;
        }
        
        .update-info {
            position: absolute;
            top: -20px;
            left: 0;
            font-size: 12px;
            color: #555;
        }
        
        .made-by {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 12px;
            color: #555;
        }
        
        .made-by a {
            color: #9e6072;
            text-decoration: underline;
            font-weight: 600;
        }
        
        .made-by a:hover {
            text-decoration: underline;
        }
        
        table {
            border-collapse: collapse;
            width: 100%;
            background-color: white;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            overflow: hidden;
            font-size: 12px;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            font-size: 13px;
        }
        
        th {
            background-color: #007bff;
            color: white;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        tr:hover {
            background-color: #e2e6ea;
            transition: 0.3s;
        }
   
        .stream-status-icon {
            margin-left: 7px;
        }
     
        .footer {
            position: fixed;
            bottom: 15px;
            width: 100%;
            text-align: center;
            font-size: 16px;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            font-weight: 600;
        }

        .footer img {
            width: 24px;
            height: 24px;
            margin-right: 4px;
        }
        
        .footer span {
            display: flex;
            align-items: center;
        }
        
        .footer a {
            color: #007bff;
            text-decoration: underline;
            margin-left: 5px;
            font-weight: 600;
        }
        
        .footer a:hover {
            text-decoration: underline;
        }
        
        .disclaimer {
            position: fixed;
            bottom: 5px;
            width: 100%;
            text-align: center;
            font-size: 12px;
            color: #777;
        }

        .changes-info {
            position: absolute;
            bottom: -20px;
            left: 0;
            font-size: 12px;
            color: #555;
        }

        .green { color: green; }
        .red { color: red; }
        .white { color: black; }

        .stream-status {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
        }

        @media (max-width: 768px) {
            .made-by, .footer, .disclaimer {
                display: none;
            }
            
            .table-container {
                width: 100%;
                overflow-x: auto;
                padding: 0 5px;
            }
    
            table {
                font-size: 10px;
                width: 100%;
            }
    
            th, td {
                padding: 4px;
                white-space: nowrap;
            }
        }
</style>
</head>
<body>
    <div class="made-by">made by <a href="https://twitch.tv/biazej" target="_blank">blazej</a></div>
    <div class="table-container">
        <div class="update-info" id="update-time">Aktualizuje tabelę...</div>
        <table>
            <thead>
                <tr>
        <th>Nick</th>
        <th>Stream</th>
        <th onclick="sortTable(0)">Rating Rapid <span> ▲</span></th>
        <th onclick="sortTable(1)">Rating Zadania <span> ▲</span></th>
        <th onclick="sortTable(2)">Gry Rapid <span> ▲</span></th>
        <th onclick="sortTable(3)">Gry Rapid Dziś <span> ▲</span></th>
        <th onclick="sortTable(4)">Zadania <span> ▲</span></th>
        <th onclick="sortTable(5)">Zadania dziś <span> ▲</span></th>
        <th onclick="sortTable(6)">Czas na zadaniach <span> ▲</span></th>
        <th onclick="sortTable(7)">Last Game <span> ▲</span></th>
                </tr>
            </thead>
            <tbody id="stats-body">
            </tbody>
        </table>
    <div class="changes-info">Liczby w () (rating) to zmiany rankingu od 00:00. (Jeśli ktoś nie ma nic znaczy, że nie zmienił swojego rankingu).</div>
    </div>

    <div class="footer">
        <img src="https://img.icons8.com/ios-glyphs/30/chess-com.png" alt="chess-com"/>
        <span>Organizowane przez <a href="https://twitch.tv/xntentacion" target="_blank">xntentacion</a></span>
    </div>
    
    <div class="disclaimer">This website is not associated with Chess.com</div>

    <script>
        const usersMap = {
            "Kasix": { username: "kasix909", link: "https://twitch.tv/kasix" },
            "Delord": { username: "Pablosabre", link: "https://twitch.tv/delordione", link2: "https://kick.com/delordione" },
            "Nieuczesana": { username: "nieuczeszek", link: "https://twitch.tv/nieuczesana" },
            "Diables": { username: "xdiables", link: "https://twitch.tv/diables" },
            "TheNitroZyniak": { username: "nitro69penetrator", link: "https://twitch.tv/thenitrozyniak", link2: "https://kick.com/niter" },
            "Tomasz Fornal": { username: "TomaszFornal", link: "https://twitch.tv/tytusc" },
            "Netrodal": { username: "didaskyler", link: "https://twitch.tv/netrodalo" },
            "RandomBruceTV": { username: "szachowytapir", link: "https://twitch.tv/randombrucetv" },
            "Bagietka Michael": { username: "bagietkaofficial", link: "https://twitch.tv/mbagietson" },
            "MokrySuchar": { username: "mokrysucharek", link: "https://twitch.tv/mokrysuchar", link2: "https://kick.com/mokrysuchar" },
            "Hiszpanitos": { username: "jakubjd", link: "https://twitch.tv/hiszpanitos" },
            "Overpow": { username: "szachowychogath", link: "https://twitch.tv/overpow" },
            "Kubon_": { username: "JaKubon000", link: "https://twitch.tv/kubon_", link2: "https://kick.com/kubon" },
            "demonzz1": { username: "demonzz1", link: "https://twitch.tv/demonzz1", link2: "https://kick.com/demonzz1" }
        };
    
        const proxies = [
            "https://bitter-dew-1113.biazej.workers.dev/?url=",
            "https://api.allorigins.win/raw?url=",
            "https://corsproxy.io/"
        ];
    
        function updateTimestamp() {
            const now = new Date();
            const formattedTime = now.toLocaleTimeString("pl-PL", { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            document.getElementById("update-time").textContent = `Tabela została zaktualizowana o godz. ${formattedTime}`;
        }

        let sortDirections = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1];	
        function sortTable(colIndex) {
            const tbody = document.getElementById("stats-body");
            let rows = Array.from(tbody.rows);
        
            rows.sort((a, b) => {
                let aVal, bVal;
        
                let aCell = a.cells[colIndex + 2]; 
                let bCell = b.cells[colIndex + 2];
        
                if (!aCell || !bCell) return 0;
        
                if (colIndex === 7) {
                    aVal = new Date(aCell.textContent).getTime();
                    bVal = new Date(bCell.textContent).getTime();
                } else if (colIndex === 6) {
                    aVal = timeToSeconds(aCell.textContent);
                    bVal = timeToSeconds(bCell.textContent);
                } else {
                    aVal = parseInt(aCell.textContent.match(/\d+/)) || 0;
                    bVal = parseInt(bCell.textContent.match(/\d+/)) || 0;
                }
        
                return (aVal - bVal) * sortDirections[colIndex];
            });
        
            sortDirections[colIndex] *= -1;
            tbody.innerHTML = ""; 
            rows.forEach(row => tbody.appendChild(row));
        
            updateSortIcons(colIndex);
        }
        	
        function timeToSeconds(timeStr) {
            const timeParts = timeStr.match(/(\d+)h (\d+)m (\d+)s/);
            if (timeParts) {
                const hours = parseInt(timeParts[1], 10);
                const minutes = parseInt(timeParts[2], 10);
                const seconds = parseInt(timeParts[3], 10);
                return (hours * 3600) + (minutes * 60) + seconds;
            }
            return 0;
        }

        function updateSortIcons(activeIndex) {
            const headers = document.querySelectorAll("th span");
        
            headers.forEach((span, index) => {
                if (index === activeIndex) {
                    span.textContent = sortDirections[index] === 1 ? " ▲" : " ▼";
                } else {
                    span.textContent = " ▲";
                }
            });
        }
        
        async function fetchWithProxy(url, proxyIndex = 0) {
            if (proxyIndex >= proxies.length) {
                throw new Error("Wszystkie proxy zawiodły.");
            }
    
            const proxyUrl = proxies[proxyIndex] + encodeURIComponent(url);
            try {
                const response = await fetch(proxyUrl);
    
                if (response.status === 429) {
                    console.warn(`Rate limit na proxy ${proxyIndex}, przełączam na kolejne.`);
                    return fetchWithProxy(url, proxyIndex + 1);
                }
    
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }
    
                return response.json();
            } catch (error) {
                console.error(`Błąd proxy ${proxyIndex}: ${error.message}`);
                return fetchWithProxy(url, proxyIndex + 1);
            }
        }
            
        async function fetchLocalData(username) {
            try {
                const response = await fetch(`dane/${username}.json`);
                if (!response.ok) throw new Error("Błąd ładowania pliku JSON");
                return await response.json();
            } catch (error) {
                console.error(`Błąd ładowania lokalnych danych dla ${username}:`, error);
                return null;
            }
        }

        async function checkStreamStatus(username, link, link2 = null) {
            const checkLink = async (streamLink) => {
                if (streamLink.includes('twitch.tv')) {
                    const twitchUsername = streamLink.split('/')[3];
                    const apiUrl = `https://decapi.me/twitch/uptime/${twitchUsername}`;
                    try {
                        const response = await fetch(apiUrl);
                        const data = await response.text();
                        return data.includes("offline") ? "Offline" : "Online";
                    } catch (error) {
                        console.error(`Błąd sprawdzania statusu streamu Twitcha dla ${username}:`, error);
                        return "Offline";
                    }
                } else if (streamLink.includes('kick.com')) {
                    const kickUsername = streamLink.split('/')[3];
                    const apiUrl = `https://kick.com/api/v2/channels/${kickUsername}`;
                    try {
                        const response = await fetch(apiUrl);
                        const data = await response.json();
                        return data.livestream === null ? "Offline" : "Online";
                    } catch (error) {
                        console.error(`Błąd sprawdzania statusu streamu Kicka dla ${username}:`, error);
                        return "Offline";
                    }
                }
                return "Offline";
            };
        
            let streamStatus = await checkLink(link);
        
            if (streamStatus === "Offline" && link2) {
                streamStatus = await checkLink(link2);
            }
        
            return streamStatus;
        }

        async function updateFooterStreamStatus() {
            const footerSpan = document.querySelector(".footer span");
        
            const twitchLink = "https://twitch.tv/xntentacion";
            const kickLink = "https://kick.com/xntentacion";
        
            let streamStatusTwitch = await checkStreamStatus("xntentacion", twitchLink);
            
            if (streamStatusTwitch === "Online") {
                footerSpan.innerHTML = `Organizowane przez 
                    <a href="${twitchLink}" target="_blank">xntentacion</a> 
                    <img src='https://i.imgur.com/WQFquis.png' alt='Online' class='stream-status-icon' />`;
                return;
            }
        
            let streamStatusKick = await checkStreamStatus("xntentacion", kickLink);
        
            if (streamStatusKick === "Online") {
                footerSpan.innerHTML = `Organizowane przez 
                    <a href="${kickLink}" target="_blank">xntentacion</a> 
                    <img src='https://i.imgur.com/WQFquis.png' alt='Online' class='stream-status-icon' />`;
                return;
            }
        
            footerSpan.innerHTML = `Organizowane przez 
                <a href="${twitchLink}" target="_blank">xntentacion</a> 
                <img src='https://i.imgur.com/IH9wGGK.png' alt='Offline' class='stream-status-icon' />`;
        }
        
        updateFooterStreamStatus();
        
        async function getChessStats(displayName, chessComData) {
            const url = `https://www.chess.com/callback/member/stats/${chessComData.username}`;
            const localData = await fetchLocalData(chessComData.username);
            
            try {
                const jsonData = await fetchWithProxy(url);
                let tacticsRating = "Brak danych";
                let rapidRating = "Brak danych";
                let lastGame = "Brak danych";
                let lastDateRapid = null;
                let lastDateTactics = null;
                let rapidGames = "0";
                let tacticsGames = "0";
                let rapidGamesToday = "0";
                let tacticsGamesToday = "0";
                let totalTacticsTime = 0;
        
                let prevTacticsRating = localData?.stats.find(s => s.key === "tactics")?.stats?.rating || null;
                let prevRapidRating = localData?.stats.find(s => s.key === "rapid")?.stats?.rating || null;
                let prevRapidGames = localData?.stats.find(s => s.key === "rapid")?.stats?.total_game_count || 0;
                let prevTacticsGames = localData?.stats.find(s => s.key === "tactics")?.stats?.attempt_count || 0;
        
                jsonData.stats.forEach(stat => {
                    if (stat.key === "tactics" && stat.stats) {
                        tacticsRating = stat.stats.rating ?? "Brak danych";
                        lastDateTactics = new Date(stat.lastDate).getTime();
                        tacticsGames = stat.stats.attempt_count ? `${stat.stats.attempt_count} (<span class='green'>${stat.stats.passed_count ?? 0}</span>/<span class='red'>${stat.stats.failed_count ?? 0}</span>)` : "0";
                        tacticsGamesToday = stat.stats.attempt_count - prevTacticsGames || "0";
                        totalTacticsTime = stat.stats.total_seconds || 0;  // Przypisanie czasu
                    }
                    if (stat.key === "rapid" && stat.stats) {
                        rapidRating = stat.stats.rating ?? "Brak danych";
                        lastDateRapid = new Date(stat.lastDate).getTime();
                        rapidGames = stat.stats.total_game_count ? `${stat.stats.total_game_count} (<span class='green'>${stat.stats.total_win_count ?? 0}</span>/<span class='red'>${stat.stats.total_loss_count ?? 0}</span>/<span class='white'>${stat.stats.total_draw_count ?? 0}</span>)` : "0";
                        rapidGamesToday = stat.stats.total_game_count - prevRapidGames || "0";
                    }
                });
        
                const lastTimestamp = Math.max(lastDateRapid || 0, lastDateTactics || 0);
                if (lastTimestamp > 0) {
                    const date = new Date(lastTimestamp).toLocaleString("pl-PL", { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    lastGame = lastTimestamp === lastDateTactics ? `${date} (Z)` : `${date} (R)`;
                }
        
                function formatRating(rating, prevRating) {
                    if (rating === "Brak danych") return "Brak danych";
                    if (prevRating !== null) {
                        let change = rating - prevRating;
                        if (change !== 0) {
                            let color = change > 0 ? "green" : "red";
                            let sign = change > 0 ? "+" : "-";
                            return `${rating} (<span style='color:${color}'>${sign}${Math.abs(change)}</span>)`;
                        }
                    }
                    return `${rating}`;
                }
        
                function formatTime(seconds) {
                    const hours = Math.floor(seconds / 3600);
                    const minutes = Math.floor((seconds % 3600) / 60);
                    const sec = seconds % 60;
                    return `${hours}h ${minutes}m ${sec}s`;
                }
        
                return { 
                    displayName, 
                    tacticsRating: formatRating(tacticsRating, prevTacticsRating), 
                    rapidRating: formatRating(rapidRating, prevRapidRating), 
                    rapidGames, 
                    rapidGamesToday,
                    tacticsGames,
                    tacticsGamesToday,
                    lastGame,
                    timeOnTactics: formatTime(totalTacticsTime),
                    link: chessComData.link,
                    streamStatus: "Sprawdzany później"
                };
                
            } catch (error) {
                console.error(`Błąd dla ${displayName}: ${error.message}`);
                return { 
                    displayName, 
                    tacticsRating: "Błąd", 
                    rapidRating: "Błąd", 
                    rapidGames: "Błąd", 
                    rapidGamesToday: "Błąd", 
                    tacticsGames: "Błąd", 
                    tacticsGamesToday: "Błąd", 
                    lastGame: "Błąd", 
                    timeOnTactics: "Błąd",
                    link: chessComData.link,
                    streamStatus: "Błąd"
                };
            }
        }

        async function populateTable() {
            const tbody = document.getElementById("stats-body");
            tbody.innerHTML = "";
            
            const statsArray = await Promise.all(
                Object.entries(usersMap).map(async ([displayName, chessComData]) => {
                    const chessStats = await getChessStats(displayName, chessComData);
                    const streamStatus = await checkStreamStatus(displayName, chessComData.link, chessComData.link2);
            
                    const finalLink = streamStatus === "Online" && chessComData.link2 ? chessComData.link2 : chessComData.link;
            
                    return {
                        ...chessStats,
                        streamStatus,
                        finalLink
                    };
                })
            );
            
            statsArray.sort((a, b) => parseInt(b.rapidRating) - parseInt(a.rapidRating));
        
            const rows = statsArray.map(({ displayName, tacticsRating, rapidRating, rapidGames, rapidGamesToday, tacticsGames, tacticsGamesToday, lastGame, timeOnTactics, finalLink, streamStatus }) => {
                const nameCell = finalLink
                    ? `<a href='${finalLink}' target='_blank' style='color: #007bff; font-weight: 300; text-decoration: none;'>${displayName}</a>`
                    : displayName;
        
                const streamIcon = streamStatus === "Online"
                    ? "<div class='stream-status'><img src='https://i.imgur.com/WQFquis.png' alt='Online' width='18' height='18' /></div>"
                    : "<div class='stream-status'><img src='https://i.imgur.com/IH9wGGK.png' alt='Offline' width='18' height='18' /></div>";
        
                return `<tr>
                            <td>${nameCell}</td>
                            <td>${streamIcon}</td>
                            <td>${rapidRating}</td>
                            <td>${tacticsRating}</td>
                            <td>${rapidGames}</td>
                            <td>${rapidGamesToday}</td>
                            <td>${tacticsGames}</td>
                            <td>${tacticsGamesToday}</td>
                            <td>${timeOnTactics}</td>
                            <td>${lastGame}</td>
                        </tr>`;
            });
        
            tbody.innerHTML = rows.join("");
            updateTimestamp();
        }
        populateTable();
    </script>
</body>
</html>
